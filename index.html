<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>self_organizing: self_organizing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">self_organizing
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceself__organizing.html" title="All structures to instaniate self-organizing lists and vectors with various find policies.">self_organizing</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#introduction">Introduction</a><ul><li class="level2"><a href="#why">Why this project?</a></li>
<li class="level2"><a href="#whatis">What is a self-organizing list?</a></li>
</ul>
</li>
<li class="level1"><a href="#considerations">Technical considerations</a></li>
<li class="level1"><a href="#principles">Design principles and considerations</a><ul><li class="level2"><a href="#policies">Policy-based design</a></li>
<li class="level2"><a href="#search">Searching for an element</a></li>
<li class="level2"><a href="#iterators">Iterator invalidation</a></li>
</ul>
</li>
<li class="level1"><a href="#performance">Performance</a><ul><li class="level2"><a href="#normal">Search of normally distributed elements</a></li>
<li class="level2"><a href="#normal-sorted">Search of normally distributed and sorted elements</a></li>
<li class="level2"><a href="#geometric">Search of geometrically distributed elements</a></li>
</ul>
</li>
<li class="level1"><a href="#sample">Sample code</a></li>
<li class="level1"><a href="#license">License</a></li>
<li class="level1"><a href="#references">References</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<h2><a class="anchor" id="why"></a>
Why this project?</h2>
<p>I started this project the same way I started a few others already. I cracked open my "Data Structures and Algorithm Analysis"<sup>[1]</sup> book from college and browsed its table of contents for an interesting concept to implement in C++11. This project is about exploring what the new C++ standard offers and putting it in practice in smallish, self-contained libraries. I'm also using this project to try out GitHub's offering. This project is <em>not</em> the most perfomant and efficient self-orginizing list you've ever seen. In fact, after running some crude performance benchmark, I've concluded its advantage window is quite narrow. More on that down below.</p>
<h2><a class="anchor" id="whatis"></a>
What is a self-organizing list?</h2>
<p>A self-organizing list is a container that attempts to optimize future searches based on past searches. Because a search in a list is a linear operation, the closer to the head an element is, the faster it is to find it. Popular elements should therefore move closer to the head of the list over time to optimize future searches. Less popular elements will drift to the tail of the list. You might recognize in this description an implementation of the "80/20" rule for lists.</p>
<p>Different self-organizing strategies exist, the following three are offered in this library. </p>
<ul>
<li><b>Count</b>. Elements are kept ordered by the frequency of past searches. An element that has been searched for <code>N</code> times is moved ahead of all elements that have been searched for less than <code>N</code> times. </li>
<li><b>Transpose</b>. When an element is searched for, it is swapped with the element in front of it. </li>
<li><b>Move-to-front</b>. When an element is searched for, it is moved to the front of the list.</li>
</ul>
<h1><a class="anchor" id="considerations"></a>
Technical considerations</h1>
<p>Because of the motivation for this project to learn C++11 and put it in practice, you will obviously need a C++11 compliant compiler and library. I'm using Visual Studio 2012 to develop but I additionally test with g++ 4.6 and XCode 4.5. I'm not using advanced or arcane C++11 features, so earlier version of these toolchains might also work.</p>
<h1><a class="anchor" id="principles"></a>
Design principles and considerations</h1>
<h2><a class="anchor" id="policies"></a>
Policy-based design</h2>
<p>The public API of this library consists of two container classes and three policy classes to be used as template parameters for the container classes.</p>
<p>The two container classes are <a class="el" href="classself__organizing_1_1list.html">self_organizing::list</a> and <a class="el" href="classself__organizing_1_1vector.html">self_organizing::vector</a>. They distinguish themselves by which container from the <code>std</code> namespace they use to hold data. Why offer <code>std::vector</code> as a possible data holder for something called "self-organizing list"? Because I can. But also because it helps to compare performance of such an animal with a that of a self-organizing list implemented with an actual list.</p>
<p>The policy classes each implement a self-organizing strategy. All three classes are defined in <a class="el" href="namespaceself__organizing_1_1find__policy.html">self_organizing::find_policy</a>.</p>
<h2><a class="anchor" id="search"></a>
Searching for an element</h2>
<p>Searching for an element in a <code>std::vector</code> or a <code>std::list</code> is performed with the generic <code>std::find</code> from the <code>&lt;algorithm&gt;</code> header. On the ther hand, <a class="el" href="classself__organizing_1_1list.html">self_organizing::list</a> and <a class="el" href="classself__organizing_1_1vector.html">self_organizing::vector</a> provide <a class="el" href="classself__organizing_1_1detail_1_1container.html#aaa931b75023e8aaa4c7246841d9ff664">find</a> member function. It is important to note that, by definition, a container's elements are re-ordered when a <code>find</code> operation is performed. Therefore, the <code>find</code> member is not <code>const</code>.</p>
<h2><a class="anchor" id="iterators"></a>
Iterator invalidation</h2>
<p>Iterator invalidation rules for a self-organizing container follow the same rules as for containers from the <code>std</code> namespace with one exception. <a class="el" href="classself__organizing_1_1detail_1_1container.html#af6724a2b931da18b4c946720a8267c7b">self_organizing::vector::iterator</a> is invalidated after performing a search. This follows from the facts that a self-organizing container is re-ordered after a search is performed and that when elements from a <code>std::vector</code> are re-ordered, it's iterators are invalidated. This exception does not apply to <a class="el" href="classself__organizing_1_1detail_1_1container.html#af6724a2b931da18b4c946720a8267c7b">self_organizing::list::iterator</a>.</p>
<h1><a class="anchor" id="performance"></a>
Performance</h1>
<p>So, are they worth it?</p>
<p>We already know that when searching for elements in a container in a purely random fashion, a self-organizing list will offer no performance improvement, only overhead. There would indeed be no useful information from past searches to use and optimize future searches. Self-organizing lists must only be used when searches are not uniformly random.</p>
<p>I'll state upfront that if one considers only the time taken to search, <code>std::unordered_set</code> and <code>std::set</code> are virtually unbeatable under the conditions I've set for these tests. The only way I could get <code>self_organizing::lists</code> to come ahead of was when I included the time taken to construct the container in the overall performance evaluation. So that's something important to consider.</p>
<p>Performance tests were run with two random distributions, normal and geometric. After the numbers were generated, an extra step was performed to substitute the generated numbers with values from a randomly generated substitution dictionary. This avoided having the numbers generated being too predictable or concentrated. For instance, for a geometric distribution, even though the distribution is random, the most common number generated will <em>always</em> be 0, the second will <em>always</em> be 1, etc. Thus, this extra step added randomness to the numbers themselves, rather than just their distribution.</p>
<h2><a class="anchor" id="normal"></a>
Search of normally distributed elements</h2>
<p>For this performance test, I used the following containers:</p>
<ul>
<li>One <code>std::set</code>, one <code>std::unordered_set</code>, one <code>std::list</code> and one <code>std::vector</code>.</li>
<li>Three <a class="el" href="classself__organizing_1_1list.html" title="A self-organizing container that uses a std::list to hold its data.">self_organizing::list</a>, each with a different <a class="el" href="namespaceself__organizing_1_1find__policy.html">find_policy</a>.</li>
<li>Three <a class="el" href="classself__organizing_1_1vector.html" title="A self-organizing container that uses a std::vector to hold its data.">self_organizing::vector</a>, each with a different <a class="el" href="namespaceself__organizing_1_1find__policy.html">find_policy</a>.</li>
</ul>
<p>Each container was constructed with value from the range [0, 999999[. I then generate 100000 random integers from the same range using a <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal distribution</a>. Each time, the mean was kept at 50000 and the variance was changed. Then, the extra susbstitution step described above was applied.</p>
<div class="image">
<img src="performance-normal.png" alt="performance-normal.png"/>
</div>
<p>First obvious conclusion: <code>std::set</code> and <code>std::unordered_set</code> crush the competition. They barely register on the graph. <code>std::set's</code> <em>O(log(N))</em> search performance shines. <code>std::unordered_set's</code> amortized constant performance fares even better, though it doesn't show on the graph. Sorting or hashing the data even appears to have been done for free when compared to the other containers' performance.</p>
<p>On the other side of the spectrum, <code>self_organizing::vector&lt;find_policy::count&gt;</code> and <code>self_organizing::vector&lt;find_policy::move_to_front&gt;</code> can't keep up at all. The maintenance required is utterly misadapted to a <code>vector</code> since both policies constanly rearrange elements using insertion, an operation that <code>std::vector</code> is not made for.</p>
<p>What's left in between? In fourth place we have <code>std::vector</code>. The nature of this test favors packed and static data, so that's no surprise. But ahead of it by a nose is <code>self_organizing::vector&lt;find_policy::transpose&gt;</code>. The transposition strategy of swapping element incurs little overhead to <code>std::vector</code> and afforded it the second place.</p>
<p>Where are our lists? <code>std::list</code> and <code>self_organizing::list&lt;find_policy::transpose&gt;</code> performed in lock-step, mimicking their <code>vector</code> cousins. Only, three times slower. Remains, <code>self_organizing::list&lt;find_policy::count&gt;</code> and <code>self_organizing::list&lt;find_policy::move_to_front&gt;</code>. Now those are interesting because they show a pattern of improving performance as the search variance is reduced. <code>self_organizing::list&lt;find_policy::move_to_front&gt;</code> even managed to come ahead of the <code>vectors</code> in the last test! Are self-organized lists vindicated? Not quite. To favor a self-organizing list as your container in this scenario, you would have to know in advance that your future searches will be performed on a very small subset of your data. A variance of 1000 means that about two-thirds of searches will be performed on a window of 2000 elements. It also implies that virtually all searches will be performed on a window of six times the variance value, or 6000. Given our container size of 100000, it's a far cry from the "80/20" ratio.</p>
<p>But let's try to give our self-organizing containers a fighting chance...</p>
<h2><a class="anchor" id="normal-sorted"></a>
Search of normally distributed and sorted elements</h2>
<p>This next test is a carbon copy of the previous test except that the elements to search are sorted after they are generated. The purpose is to imitate a system where it is expected that not only a small subset of elements will be searched for, but also that when an element is searched for it is highly likely to be immediately searched for again. This situation will not help the transposition strategy but should help the move-to-front strategy. Let's see.</p>
<div class="image">
<img src="performance-normal-sorted.png" alt="performance-normal-sorted.png"/>
</div>
<p>The picture is the same as before except for the performance of <code>self_organizing::list&lt;find_policy::move_to_front&gt;</code>. It has benefited tremendeously from the search pattern, equating or besting the performance of <code>std::vector</code> for the smaller variance values. But, it still doesn't hold a candle to either of <code>std::set</code> and <code>std::unordered_set</code>. Let's up the ante.</p>
<h2><a class="anchor" id="geometric"></a>
Search of geometrically distributed elements</h2>
<p>Using knowledge from the previous tests, I narrowed the contenders to the following four:</p>
<ul>
<li>One <code>std::set</code> </li>
<li>One <code>std::unordered_set</code> </li>
<li>One <code>self_organizing::list&lt;find_policy::count&gt;</code> </li>
<li>One <code>self_organizing::list&lt;find_policy::move_to_front&gt;</code> </li>
</ul>
<p>Each container was constructed with value from the range [0, 999999[. I then generated 100000 random integers multiple times from the same range using a &lt; href=<a href="http://en.wikipedia.org/wiki/Geometric_distribution">http://en.wikipedia.org/wiki/Geometric_distribution</a>&gt;geometric distribution and varying <em>p</em>. I measure both the time taken to contruct the container and the time taken to perform the searches twenty-five times to average out any outlying result.</p>
<div class="image">
<img src="performance-geometric-100000.png" alt="performance-geometric-100000.png"/>
</div>
<p>Self-organizing lists beat <code>std::set!</code> Victory!</p>
<p>Alas, it is a short-lived victory. These values of <em>p</em> are ridiculously small. At <em>p = 0.2</em> &mdash;the largest for which <code>self_organizing::lists</code> beat <code>std::set</code>&mdash; the variance is a measly <a href="http://www.wolframalpha.com/input/?i=GeometricDistribution[0.2]">20</a>.</p>
<p>Can we do better by making the sets do worse? Consider that these tests measure both construction time and search time. For <code>std::set</code> that means <em>O(Nlog(N))</em> construction performance and <em>O(log(N))</em> search performance. Thus, if the size of the data set goes up by an order of magnitude, the overall performance of <code>std::set</code> should degrade proportionally. As for <code>std::unordered_set</code>, it's construction performance is <em>O(N)</em> but it incurs hashing overhead. So, our <code>self_organizing::lists</code> are at an advantage when considering construction performance but let's hope their search strategy can keep up.</p>
<div class="image">
<img src="performance-geometric-1000000.png" alt="performance-geometric-1000000.png"/>
</div>
<p>With the size of the data set increased to one million, we managed to push <em>p</em> further down to 0.01, a variance of 9900. Or 1% of our data set. Meh.</p>
<p>So. There you have it. And I'm calling it a day.</p>
<h1><a class="anchor" id="sample"></a>
Sample code</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="self__organizing_8h.html" title="The only file you need.">self_organizing.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">namespace </span>so = self_organizing;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> data[] = {0, 1, 2, 3, 4, 5, 6, 7};</div>
<div class="line"></div>
<div class="line">    so::list&lt;int, so::find_policy::transpose&gt; soci(begin(data), end(data));</div>
<div class="line"><span class="comment">//  so::list&lt;int, so::find_policy::count&gt; soci(begin(data), end(data));</span></div>
<div class="line"><span class="comment">//  so::vector&lt;int, so::find_policy::count&gt; soci(begin(data), end(data));</span></div>
<div class="line"></div>
<div class="line">    soci.push_back(8);</div>
<div class="line"></div>
<div class="line">    copy(soci.begin(), soci.end(), ostream_iterator&lt;int&gt;(cout, <span class="stringliteral">&quot; &quot;</span>));</div>
<div class="line">    cout &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    soci.find(5);</div>
<div class="line">    soci.find(3);</div>
<div class="line">    soci.find(5);</div>
<div class="line">    soci.find(6);</div>
<div class="line">    soci.find(4);</div>
<div class="line">    soci.find(6);</div>
<div class="line">    soci.find(5);</div>
<div class="line">    soci.find(0);</div>
<div class="line">    soci.find(3);</div>
<div class="line">    soci.find(5);</div>
<div class="line">    soci.find(6);</div>
<div class="line">    soci.find(4);</div>
<div class="line"></div>
<div class="line">    copy(soci.begin(), soci.end(), ostream_iterator&lt;int&gt;(cout, <span class="stringliteral">&quot; &quot;</span>));</div>
<div class="line">    cout &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="license"></a>
License</h1>
<pre class="fragment">Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
</pre><h1><a class="anchor" id="references"></a>
References</h1>
<ol type="1">
<li>Clifford A. Shaffer. <em>A practical Introduction to Data Structures and Algorithm Analysis.</em> Prentice Hall, Upper Saddle River, NJ, 1997. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 22 2012 16:29:52 for self_organizing by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
